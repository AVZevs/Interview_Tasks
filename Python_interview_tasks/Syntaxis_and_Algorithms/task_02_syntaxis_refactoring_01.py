"""
Есть вот такая функция.

def get_first_matching_object(predicate, objects=[]):
    matching_objects = (obj for obj in objects if predicate(obj))
    if matching_objects:
        object = matching_objects[0]
        return object
    else:
        return None


- Вопрос #1: Что она делает?

Ответ на вопрос #1:

Эта функция получает на вход какое-то условие (функцию, возвращающую True или False) и список каких-то объектов.
Далее функция итерируется по этому входящему списку, проверяя каждый объект в списке на то, что функция
predicate(obj) для этого объекта вернет True или False. Если для объекта вернется True, то этот объект
добавляется в список matching_objects. Таким образом в списке matching_objects соберутся все объекты из списка
objects, для которых predicate(obj) == True.
Если же таких объектов нет, то список matching_objects окажется пустым и функция завершит свою работу
с результатом None. Если же такие объекты есть и, соответственно, список matching_objects не пустой,
то функция вернет первый элемент этого списка.


- Вопрос #2: Какие есть замечания к этому коду, описывающему эту функцию?

Ответ на вопрос #2:

1. Нет аннотации типов - не ясно какие типы используются (какой тип у объектов в списке objects и пр.).

2. Не совсем правильно передавать в функцию в качестве параметра по умолчанию
изменяемый тип данных (в данном случае мы по умолчанию передаем в функцию пустой список).
Это может привести к лишнему использованию оперативной памяти.
Лучше такую проверку реализовать в теле самой функции. Например, вот так,
    if objects is None:
        objects = []

3. Вот эта конструкция

matching_objects = (obj for obj in objects if predicate(obj))

по идее это генератор (т.к. используются круглые скобки). Но, судя по коду мы здесь
собираемся использовать List Comprehession. Чтобы все работало корректно, нудно заменить эти
круглые скобки на квадратные, то есть создать список. Должно быть вот так:

matching_objects = [obj for obj in objects if predicate(obj)]

4. В условии if ... else ... можно убрать else - результат от этого не изменится.
Получится вот так:

    if matching_objects:
        object = matching_objects[0]
        return object
    return None


С учетом пунктов 2, 3 и 4 мы получаем вот такой отрефакторенный код:

"""

# def get_first_matching_object(predicate, objects):
#     if objects is None:
#         objects = []
#     matching_objects = [obj for obj in objects if predicate(obj)]
#     if matching_objects:
#         object = matching_objects[0]
#         return object
#     return None

"""
- Вопрос #3: Если вызвать эту функцию вот таким образом

res = get_first_matching_object(lambda x: x == 1, [2, 3, 4])

Будет ли это работать, какое у нее будет поведение?

Ответ на вопрос #3:
 
Функция вернет None, так как ни один элемент в списке [2, 3, 4] не равен 1.


- Вопрос #4: Есть ли какие-то способы оптимизировать код эту функции в плане скорости и использованию памяти?

res = get_first_matching_object(lambda x: x == 1, [2, 3, 4])

Ответ на вопрос #4:
 
1. Так как функция нам должна вернуть ВСЕГДА только первый элемент из списка matching_objects, то
нет смысла проходить по всем элементам списка objects, а будет достаточно найти только первый элемент,
который будет удовлетворять условию predicate(obj) == True и завершить работу этой функции, вернув этот
найденный элемент.

Можно переписать код этой функции таким образом:
"""

def get_first_matching_object(predicate, objects):
    if objects is None:
        objects = []
    for obj in objects:
        if object := predicate(obj):
            return obj
    return None

"""
- Вопрос #5: Какая будет сложность выполнения алгоритма этой функции (алгоритмическая сложность)?

Ответ на вопрос #5:

В худшем случае, сложность алгоритма будет O(n), если подходящий элемент окажется последним в списке objects.
А в лучшем случае - O(1). 
"""


"""
- Вопрос #6: Для чего в коде, расположенном ниже этого вопроса нужна строка

if __name__ == "__main__"

Ответ на вопрос #6:

Код программы, расположенной в теле этого условия выполнится только в том случае, если на выполнение запущен именно
этот файл, в котором прописано такое условие. Если же импортировать этот наш файл в какой-либо другой файл, то
этот кусок кода в условии if __name__ == "__main__" не выполнится.
"""

if __name__ == "__main__":
    res = get_first_matching_object(lambda x: x == 1, [1, 2, 3, 4])
    print(res)
