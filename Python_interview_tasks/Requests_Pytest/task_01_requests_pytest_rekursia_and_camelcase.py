"""
----------------------------------------------------------------------------------------
ЗАДАНИЕ - Вариант #1
На лайв-кодинг. Можно выдать кандидату вот это задание и попросить написать код с нуля.
----------------------------------------------------------------------------------------

Вводная:
Есть веб-сервис, который принимает в себя GET запрос и возвращает в ответ в BODY все,
что было передано в этот запрос.

Например, вот такой код выведет примерно следующее (результат вывода может изменяться):
r = requests.get("https://httpbin.org/get", headers={"x-header": "value"})
print(r.text)

Вот что выведет этот код:
{
  "args": {},
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate",
    "Host": "httpbin.org",
    "User-Agent": "python-requests/2.32.3",
    "X-Amzn-Trace-Id": "Root=1-67c80e92-11e4c0c74c621a4f403aa644",
    "Zevs-Header": "WorkLifeBalance"
  },
  "origin": "217.170.127.228",
  "url": "https://httpbin.org/get"
}

P.S. Что конкретно в Вашем случае будет выведено можно посмотреть, запустив код, представленный выше.

Задание:
Написать автотест (использовать библиотеку PyTest), который проверит, что переданный с запросом хедер
содержится в ответе от сервера (именно в BODY ответа). Тестовые данные передать в тест через фикстуру.

То есть по сути нужно просто проверить, что сервер действительно возвращает в теле ответа те заголовки,
которые мы передали ему в хедерах. Именно такой функционал работы сервера был нам заявлен.

-------------======= РЕШЕНИЕ ЗАДАНИЯ и ПОДВОХИ =======-------------
И вот тут как раз кроется один подвох:
Названия заголовков (ключи) по стандарту должны быть регистронезависимы, а значения - регистрозависимы.
При формировании ответа сервер преобразует ключи переданных нами хедеров в CamelCase.
То есть, например, мы отправляем
{"zevs-header": "WorkLifeBalance"}, а в ответ получим {"Zevs-Header": "WorkLifeBalance"}.

Второй подвох заключается в том, что в ответе возвращается двухуровневый JSON (а в реальности может быть и больше
уровней вложенности). И нужный нам хедер расположен именно во вложенном словаре. То есть до него нужно как-то
добраться. Здесь поможет написание функции, которая рекурсивно пробежится по всем словарям, в том числе
и вложенным и вернет True, если искомый хедер будет найден.

----------------------------------------------------------------------------------------
ЗАДАНИЕ - Вариант #1.1
Если мы пошли по пути лайв-кодинга, то тут уже придется поимпровизировать, так как хрен знает, что кандидат напишет.
Может у него своё видение решения этой задачи.
----------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------
ЗАДАНИЕ - Вариант #2
Либо не заставлять кандидата писать код с нуля, а дать ему уже этот готовый код и дать задание, чтобы кандидат
рассказал для чего нужен этот код, что и как он делает. Причем само задание из варианта #1 кандидату давать не надо!
Даём только исходник, без всяких вводных, как перед лайв-кодингом.
----------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------
ЗАДАНИЕ - Вариант #2.1
Предположим мы дали кандидату этот исходник и он нам что-то рассказал про его работу.
А теперь надо попросить кандидата найти ошибки в этом коде (точнее в алгоритме). А ошибка здесь точно есть,
несмотря на то, что программка работает на первый взгляд корректно.

Hint: Ошибка в том, что значения ключей в хедерах регистроЗАвисимы, а мы их все для дальнейшего сравнения приводим
к нижнему регистру. А это неправильно. Ключи - да, нужно привести к одному регистру, а значения - нет!

Hint: Еще одна ошибка (точнее, даже не ошибка, а просто неоптимальное использование памяти) есть в функции def request_url().
Там мы суммируем (конкатенция) строковые переменные, создавая еще одну лишнюю переменную, которая занимает
лишнюю память. А можно просто возвращать значение сразу, например, через f-строки. Нужная строчка там в коде этой
функции закомментирована. Вот ее нужно раскомментить, а все остальные строки в объявлении этой функции - удалить.
----------------------------------------------------------------------------------------

ЗАДАНИЕ - Вариант #2.2
Можно еще спросить кандидата, что означает строчка "-> bool:" написанная при объявлении функции

def search_in_nested_dict(dictionary, key, value) -> bool:

Hint: Это аннотации типов.

Можно спросить у кандидата, знает ли он что это такое "аннотации типов" и для чего это нужно?

Hint: Аннотации типов на самом деле просто подсказки для разработчиков, чтобы разрабы сразу видели какой тип
данных ожидается для корректной работы кода. Но на сам код эти аннотации типов никакого влияния не оказывают.

То есть, мы аннотируем при описании этой функции то, что она возвращает булево значение. Но при этом, если вдруг
эта функция вернет, например, строку или число и т.д., то никаких ошибок интерпретор не выдаст.
---------------------------------------------------------------------------------------

Еще вариант дополнительного задания: Можно попросить кандидата самостоятельно написать простейший тест на проверку
того, что сервер правильно ответил на все наши запросы, то есть вернул статус-код 200.
Кандидат может добавить еще один assert в предыдущую функцию, но обычно так не делают. Каждый тест - это отдельная
функция со своим единственным assert-ом.

Вот такой код этого теста должен получиться:

def test_success_response(request_url, request_header):
    response = requests.get(request_url, headers=request_header)
    assert response.status_code == 200, f"Error: Status code is not 200! (Получили код {response.status_code} )"
"""
import requests
import pytest

base_url = "https://httpbin.org"
endpoint = "/get"

def search_in_nested_dict(dictionary, key, value) -> bool:
    if isinstance(dictionary, dict):
        for k, v in dictionary.items():
            k_lower = str(k).lower()
            v_lower = str(v).lower()
            if k_lower == key and v_lower == value:
                return True
                    # -------------------------
                    # А вот так будет правильно:
                    # v_lower = str(v).lower() - Эту строчку можно удалить вообще!!!
                    # if k_lower == key and v == value:
                    #     return True
                    # -------------------------
            if search_in_nested_dict(v, key, value):
                return True
    return False

@pytest.fixture
def request_url():
    full_url = base_url + endpoint
    return full_url
    # return f"{base_url}{endpoint}"

@pytest.fixture(params=[
    {"zevs-header": "WorkLifeBalance"},
    {"Zevs-Header": "worklifebalance"},
    {"MY-head": "workBALAnce"}
])
def request_header(request):
    return request.param

def test_header_exists(request_url, request_header):
    response = requests.get(request_url, headers=request_header)
    response_json = response.json()

    for key, value in request_header.items():
        # И в этой строки ниже тоже нужно изменить value.lower() просто на value
        assert search_in_nested_dict(response_json, key.lower(), value.lower()), f"Хедер '{key}:{value}' НЕ найден в ответе."
