"""
Декораторы для джуниор.
Это довольно частый вопрос на собесах. Плюс декораторы реально часто используются.


* ВАРИАНТЫ:
  Тут можно использовать два подхода:
  1 - Дать кандидату задания, чтобы он написал этот код с нуля и уже исходя из результата "плясать" далее
  2 - Дать кандидату уже готовый слегка неоптимальный код и попросить рассказать как работает этот код, что должен
      делать, что реально делает и т.д. Причем желательно подробно практически про каждую строчку кода, ибо общую
      логику программы можно угадать, а вот, например, как тут используются срезу (а они тут есть) можно и
      не понимать.


Задача: Существует текстовый файл, состоящий из нескольких строк. Преположим, файл состоит из 4-х строк. Необходимо
написать программу, которая считывает этот файл и преобразует его следующим образом:
1. Первая строка из файла обрамляется тегами <h1>stroka_1</h1>
2. Вторая и последующие строки обрамляются тегами <p>stroka_N</p>
3. Все строки уже после преобразований 1 и 2 обрамляются тегами <html>...</html>

Обязательное условие - использование декораторов при написании кода!

- Вопрос #1: Что такое декораторы в Python и для чего они нужны?

Ответ на вопрос #1:

Тут много печатать надо. Надо, чтобы собеседующий сам понимал суть этого понятия.


- Вопрос #2: Какие явные и довольно критичные недостатки Вы видите в этом коде? Возможно, имеет смысл переписать
некоторые куски кода? И пусть кандидат сам перепишет эту функцию.

Ответ на вопрос #2:

1. Явные недостатки имеются в функции loading_text_from_file(filename):
1.1. Мы открываем файл на чтение, но после прочтения не закрываем его -> можем терять память
1.2. Мы не делаем проверку на отсутствие файла. Если файла не будет - программа упадет с ошибкой.

По хорошему код этой функции должен выглядеть примерно вот так (с учетом выше указанных недостатков):

def loading_text_from_file(filename):
    try:
        with open(filename, "r", encoding="utf-8") as file:
            data = file.readlines()
            return data
    except FileNotFoundError:
        print(f"File '{filename}' not found!")

2. Также функция loading_text_from_file(filename) считывает весь файл целиком в память и держит его там.
Такое решение пойдет, если мы заранее знаем, что файл небольшой. А если, предположим, это огромный файл
весом в 16Gb, то могут возникнуть непредвиденные проблемы.

По-хорошему здесь нужно читать файл как-то используя генератор. СТОИТ ЛИ ЭТО ЗДЕСЬ ДЛЯ СОБЕСА ДЕЛАТЬ? ПОДУМАТЬ!

3. Это уже для продвинутых кандидатов. В функциях-декораторах html_wrapper(func), h1_wrapper(func) и p_wrapper(func)
мы не используем метод (декоратор) wraps() из штатной библиотеки functools. Как бы и без этого все будет работать
нормально, но с использованием этой библиотеки мы сможем получать "служебные" данные нашей основной функции
из самого декоратора, например, docstrings. Это если кратко.

Чтобы это реализовать нужно сделать вот такой импорт

from functools import wraps

и в каждом нашем декораторе перед строкой def wrapper(*args, **kwargs): прописать строку @wraps(func).


- Вопрос #3: Сейчас полученный html просто выводится на экран. Попросить кандидата дописать программу так, чтобы
она кроме вывода на экран сохраняла этот html в файл task_03_data_out.html. Реализовать запись в файл через
отдельную функцию.

Ответ на вопрос #3:

Эта функция записи в файл будет выглядеть примерно так:

def save_html_to_file(filename, data):
    try:
        with open(filename, "w", encoding="utf-8") as file:
            file.write(data)
    except EOFError:
        print("Error writing file.")

И потом нужно еще на забыть ее вызвать в основном теле программы, в том месте где мы распечатываем текст на экран.

Вот так, например:

print(result)
save_html_to_file("task_03_data_out.html", result)
"""

def html_wrapper(func):
    def wrapper(*args, **kwargs):
        content = func(*args, **kwargs)
        return f"<html>\n{content}\n</html>"
    return wrapper


def h1_wrapper(func):
    def wrapper(*args, **kwargs):
        content = func(*args, **kwargs)
        return f"<h1>{content}</h1>"
    return wrapper


def p_wrapper(func):
    def wrapper(*args, **kwargs):
        content = func(*args, **kwargs)
        return f"<p>{content}</p>"
    return wrapper


def loading_text_from_file(filename):
    file = open(filename, "r", encoding="utf-8")
    data = file.readlines()
    return data


@h1_wrapper
def wrap_first_line(line):
    return line.strip()


@p_wrapper
def wrap_other_line(line):
    return line.strip()


@html_wrapper
def process_an_text(lines: list):
    first_line = wrap_first_line(lines[0])
    other_lines = "\n".join([wrap_other_line(line) for line in lines[1:]])
    return f"{first_line}\n{other_lines}"


if __name__ == "__main__":
    file_name = "task_03_data.txt"
    data = loading_text_from_file(file_name)
    if data:
        result = process_an_text(data)
        print(result)
