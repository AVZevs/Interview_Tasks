"""
Декораторы для джуниор.
Это довольно частый вопрос на собесах. Плюс декораторы реально часто используются.

Info: Здесь используются декораторы без параметров! Посмотри вопрос #4 ниже!

ЗАДАЧА: В этой задаче мы не будем просить кандидата написать какой-то код, а сразу предоставим ему исходник для того,
чтобы кандидат объяснил нам что делает этот код, и желательно подробнее.

Не надо заранее спрашивать кандидата про декораторы и каким-либо образом намекать на их использование в этом коде!
Если кандидат разбирается в теме, то он сам вам расскажет, что в этом коде используются декораторы. И уже тогда
можно спросить кандидата, чтобы он рассказал про декораторы все, что знает ;)


Hint (А что собственно делает этот код?):

Здесь все просто. Это пример работы декораторов. В частности этот пример еще показывает то, что декораторы применяются
к декорируемой функции снизу вверх. Это тоже важно. Так вот, в этом коде есть функция основная функция
def print_basic_text(basic_text: str) -> str, которая ничего особенного не делает, а просто возвращает переданное ей
значение в формате строки. Эта функция обернута 3-мя (тремя) декораторами, которые применяются к ней снизу вверх.
Как и должны работать декораторы.

Теперь ближе к теме. В результате своей работы программа выдаст нам фразу "Каждый охотник желает знать, где сидит фазан."
А формироваться эта строка будет постепенно, как раз с использованием декораторов.

Зы. Сначала я написал код, где использовал голый, открытый тескт "Каждый охотник желает знать, где сидит фазан.", но
при таком раскладе кандидат может и сообразить и догадаться, что делает программа (даже, если не знает про
декораторы). А нам этого не надо. По-этому я закодировал оригинальный текст в Base64 - теперь сходу сложно понять, что
зашито в этом тексте. А уже нужные функции производят декодиривание из Base64 в текст.
То есть, если дать кандидату выполнить этот код, то он увидит на экране нужный текст в чистом виде. По-этому не стоит
запускать этот код до того момента, пока кандидат не объяснит, что делает эта программа.

Если кандидат в теме про декораторы, то можно ему позадавать вопросы.

- Вопрос #1: Это уже для продвинутых кандидатов.
             Какие недостатки Вы видите в этом коде? Возможно, имеет смысл что-то дописать в этот код?

Ответ на вопрос #1:

В функциях-декораторах, прописанных в этом коде мы не используем метод (декоратор) wraps() из штатной библиотеки
functools. Как бы и без этого все будет работать нормально, но с использованием этой библиотеки мы сможем получать
"служебные" данные нашей основной функции из самого декоратора. Например, те же docstrings нам будут возвращаться от
функции-декоратора, а не от декорируемой функции. Это если кратко.

Чтобы это исправить нужно сделать вот такой импорт

from functools import wraps

и в каждом нашем декораторе перед строкой def wrapper(*args, **kwargs): прописать строку @wraps(func).

Можно еще поспрашивать про *args и *kwargs.


- Вопрос #2: Обратите внимание, как реализована функция

def print_basic_text(basic_text: str) -> str:
    return f"{b64decode(basic_text.encode("utf-8")).decode("utf-8")}"

Почему здесь строка "(basic_text: str) -> str" записана именно в таком виде? Для чего здесь эти "str" сделаны?
Что они дают?

Ответ на вопрос #2:

Это аннотации типов. Нужны в основном для подсказок разработчикам, на выполнение кода никак не влияют.


- Вопрос #3 (вытекает из вопроса #2): То есть, судя по использованию аннотации типов, функция
def print_basic_text(basic_text: str) -> str должна вернуть строку. А что будет если мы перепишем код функции вот
таким образом, как в коде ниже (то есть теперь функция вернет числовое значение)?

def print_basic_text(basic_text: str) -> str
    return 3267

Ответ на вопрос #3:

Код не сломается и будет работать. Функция вернет числовое значение 3267.
Стоит заметить, что современные IDE, например PyCharm, сделают предупреждение о несоответствии возвращаемого
функцией значиения с аннотацией.


- Вопрос #4: Как видно в функциях ZZZ_text_outer(func) используется практически одинаковый код. Имеет смысл
вынести этот код в отдельную функцию и ОЧЕНЬ ЖЕЛАТЕЛЬНО решить этот вопрос также с использованием декораторов.
Попросить кандидата сделать это. Надо воспользоваться декораторами с параметрами.

Ответ на вопрос #4:

Как это реализовать и, соответственно, ответ на этот вопрос смотрим в файле task_02_decorators_junior_middle.py.
Там точно такой же код, как и здесь, только с учетом этого вопроса #4. Просто теперь будут использоваться
декораторы с параметрами.

"""
from base64 import b64decode

def one_text_outer(func):
    def wrapper(*args, **kwargs):
        left, right = "0LbQtdC70LDQtdGC", "0LPQtNC1LA=="
        result = (f"{b64decode(left.encode("utf-8")).decode("utf-8")} {func(*args, **kwargs)} "
                  f"{b64decode(right.encode("utf-8")).decode("utf-8")}")
        return result
    return wrapper

def two_text_outer(func):
    def wrapper(*args, **kwargs):
        left, right = "0L7RhdC+0YLQvdC40Lo=", "0YHQuNC00LjRgg=="
        result = (f"{b64decode(left.encode("utf-8")).decode("utf-8")} {func(*args, **kwargs)} "
                  f"{b64decode(right.encode("utf-8")).decode("utf-8")}")
        return result
    return wrapper

def three_text_outer(func):
    def wrapper(*args, **kwargs):
        left, right = "0JrQsNC20LTRi9C5", "0YTQsNC30LDQvS4="
        result = (f"{b64decode(left.encode("utf-8")).decode("utf-8")} {func(*args, **kwargs)} "
                  f"{b64decode(right.encode("utf-8")).decode("utf-8")}")
        return result
    return wrapper

@three_text_outer
@two_text_outer
@one_text_outer
def print_basic_text(basic_text: str) -> str:
    return f"{b64decode(basic_text.encode("utf-8")).decode("utf-8")}"

if __name__ == "__main__":
    print(print_basic_text("0LfQvdCw0YLRjA=="))
